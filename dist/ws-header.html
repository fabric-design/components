<!-- inject:global -->
<!-- endinject -->
<template>
    <div class="ws-header">
        <!-- inject:html -->
        <div class="refills-patterns refills-components">
  <header class="navigation" role="banner">
    <div class="navigation-wrapper">
      <content select=".logo">
        <!-- Logo -->
      </content>
      <a href="javascript:void(0)" class="navigation-menu-button" id="js-mobile-menu">MENU</a>
      <nav role="navigation">
        <ul id="js-navigation-menu" class="navigation-menu show">
          <content select=".nav-link">
            <!-- Additional Items -->
          </content>
          <li class="nav-link more dropdown-menu">
            <a href="javascript:void(0)">
              <span id="selectedLanguageFlag" class="flag"></span>
              <span id="selectedLanguage"></span>
            </a>
            <ul class="submenu" id="languages">
            </ul>
          </li>
          <li class="nav-link" id="loggedInInfo">
          </li>
        </ul>
      </nav>
    </div>
  </header>
</div>
        <!-- endinject -->
    </div>
    <style>
        ws-header > .light-dom {
            display: none;
        }
        /* inject:styles */
        /* endinject */
    </style>
</template>

<script>
(function(){
    /* inject:js */
    'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//Get the contents of the template (_currentScript is available with webcomponents.js, use currentScript if you don't use this Polyfill)
var template = (document._currentScript || document.currentScript).ownerDocument.querySelector('template');
var availableLanguages = ['de', 'en'];
var state = {
	tokenName: "zalando-internal-access_token",
	stateName: "zalando-internal-access_state",
	languageName: 'language',
	cookiePath: '/',
	cookieDomain: '.zalan.do',
	lang: null,
	loggedIn: null,
	clientId: null,
	redirectUrl: null,
	userServiceUrl: null,
	tokenInfoUrl: null
};
// Remember url at loadtime to not have sideeffects by ie Angular2
var urlAtStart = window.location.href;

var WSHeader = function (_HTMLElement) {
	_inherits(WSHeader, _HTMLElement);

	function WSHeader() {
		_classCallCheck(this, WSHeader);

		return _possibleConstructorReturn(this, (WSHeader.__proto__ || Object.getPrototypeOf(WSHeader)).apply(this, arguments));
	}

	_createClass(WSHeader, [{
		key: 'createdCallback',

		// Use createdCallback instead of constructor to init an element.
		value: function createdCallback() {
			var _this2 = this;

			var clone = document.importNode(template.content, true);

			// This element uses Shadow DOM.
			applyTemplate(this, clone);
			// this.appendChild(clone);

			this.state = state;
			this.getAttributes();

			this.setupLanguages();

			// would fire initial before

			document.addEventListener("WebComponentsReady", function () {
				var lang = _this2.getLanguage();
				_this2.setLanguage(lang);

				_this2.checkIsLoggedIn().then(function () {
					return _this2.getUser();
				}).then(function () {
					return _this2.showUser();
				}).catch(function (err) {
					var message = "Getting Token-/User-Info failed!";
					if (err) {
						message += " " + err.toString();
					}
					_this2.propagateError(message);
				});
			});
		}
	}, {
		key: 'propagateError',
		value: function propagateError(reason) {
			var event = new CustomEvent("error", {
				detail: {
					message: reason
				}
			});
			this.dispatchEvent(event);
		}
	}, {
		key: 'getAttributes',
		value: function getAttributes() {
			this.state = Object.assign({}, this.state, {
				clientId: this.getAttribute('client-id'),
				redirectUrl: this.getAttribute('redirect-url'),
				userServiceUrl: this.getAttribute('userservice-url'),
				tokenInfoUrl: this.getAttribute('tokeninfo-url')
			});
		}
	}, {
		key: 'setupLanguages',
		value: function setupLanguages() {
			var _this3 = this;

			var languagesElem = this.querySelector('#languages');

			availableLanguages.map(function (lang) {
				var dummy = document.createElement('div');
				dummy.innerHTML = '<li>\n                <a><span class="flag flag-' + lang + '"></span> <span translate="global.language.{{lang}}">' + lang + '</span></a>\n            </li>';
				var node = dummy.childNodes[0];
				node.addEventListener("click", function () {
					return _this3.setLanguage(lang);
				});
				languagesElem.appendChild(node);
			});
		}
	}, {
		key: 'getLanguage',
		value: function getLanguage() {
			return this.state.lang || window.localStorage.getItem(this.state.languageName) || availableLanguages[0];
		}
	}, {
		key: 'setLanguage',
		value: function setLanguage(lang) {
			if (this.state.lang != lang) {
				this.state.lang = lang;
				window.localStorage.setItem(this.state.languageName, lang);
				this.showLanguage(lang);
				this.propagateLanguageChange(lang);
			}
		}
	}, {
		key: 'showLanguage',
		value: function showLanguage(lang) {
			this.querySelector('#selectedLanguageFlag').className = "flag flag-" + lang;
			this.querySelector('#selectedLanguage').innerText = lang;
		}
	}, {
		key: 'propagateLanguageChange',
		value: function propagateLanguageChange(lang) {
			var event = new CustomEvent("language-changed", {
				detail: {
					language: lang
				}
			});
			this.dispatchEvent(event);
		}
	}, {
		key: 'login',
		value: function login() {
			var url = "https://auth.zalando.com/z/oauth2/authorize?realm=/employees&response_type=token&scope=uid" + "&client_id=" + this.state.clientId + "&redirect_uri=" + this.state.redirectUrl + "&state=" + this.setSessionState();

			window.location.href = url;
		}
	}, {
		key: 'logout',
		value: function logout() {
			this.removeCookie();

			this.showLoggedOut();
			this.propagateLoginStatusChange(false);
		}
	}, {
		key: 'checkIsLoggedIn',
		value: function checkIsLoggedIn() {
			var _this4 = this;

			return new Promise(function (resolve, reject) {
				_this4.getToken(urlAtStart).then(function (token) {
					// checking that token is still valid
					_this4.getTokenInfo().then(function () {
						_this4.showLoggedIn();

						_this4.propagateLoginStatusChange(true, token);
						resolve();
					}, function (err) {
						_this4.logout();
						reject(err);
					});
				}, function (err) {
					_this4.logout();
					reject(err);
				});
			});
		}
	}, {
		key: 'propagateLoginStatusChange',
		value: function propagateLoginStatusChange(isLoggedIn, token) {
			if (this.state.loggedIn !== isLoggedIn) {
				this.state.loggedIn = isLoggedIn;

				var event = new CustomEvent("login-status-changed", {
					detail: {
						loggedIn: isLoggedIn,
						token: token || null
					}
				});
				this.dispatchEvent(event);
			}
		}
	}, {
		key: 'showLoggedOut',
		value: function showLoggedOut() {
			var loggedInInfo = this.querySelector('#loggedInInfo');
			loggedInInfo.innerHTML = '<a class="auto-size"><span translate="global.menu.signein">Login</span></i></a>';
			loggedInInfo.removeEventListener("click", this.logout);
			loggedInInfo.addEventListener("click", this.login.bind(this));
		}
	}, {
		key: 'showLoggedIn',
		value: function showLoggedIn() {
			var loggedInInfo = this.querySelector('#loggedInInfo');
			loggedInInfo.innerHTML = '<span translate="global.menu.signedinas"></span>\n\t\t\t<span id="userName">Loading...</span>\n\t\t\t<a class="auto-size" id="logOutButton" type="button"><div id="logOutIcon"></div></a>';
			loggedInInfo.removeEventListener("click", this.login);
			loggedInInfo.addEventListener("click", this.logout.bind(this));
		}
	}, {
		key: 'setSessionState',
		value: function setSessionState() {
			// create new state guid
			var state = this.guid();

			// save the state to check for it on return
			window.localStorage.setItem(this.state.stateName, state);
			return state;
		}
	}, {
		key: 'checkSessionState',
		value: function checkSessionState(state) {
			var valid = window.localStorage.getItem(this.state.stateName) === state;
			window.localStorage.removeItem(this.state.stateName);
			return valid;
		}
	}, {
		key: 'getToken',
		value: function getToken(url) {
			var _this5 = this;

			if (!url) {
				url = window.location.href;
			}
			return new Promise(function (resolve, reject) {
				var token = _this5.getTokenFromUrl(url);
				if (token) {
					var sessionState = _this5.getStateFromUrl(url);
					if (_this5.checkSessionState(sessionState)) {
						_this5.setCookie(token);
						return resolve(token);
					}
				}
				token = _this5.getCookieValue(_this5.state.tokenName);
				if (token) {
					return resolve(token);
				}

				reject();
			});
		}
	}, {
		key: 'getTokenFromUrl',
		value: function getTokenFromUrl(url) {
			var urlQueryTokenPart = /access_token=([^&]+)/.exec(url);
			return urlQueryTokenPart != null ? urlQueryTokenPart[1] : null;
		}
	}, {
		key: 'getStateFromUrl',
		value: function getStateFromUrl(url) {
			var urlQueryStatePart = /state=([^&]+)/.exec(url);
			return urlQueryStatePart[1];
		}
	}, {
		key: 'getTokenInfo',
		value: function getTokenInfo() {
			var _this6 = this;

			return new Promise(function (resolve, reject) {
				_this6.request('GET', _this6.state.tokenInfoUrl).then(function (data) {
					_this6.state = Object.assign({}, _this6.state, {
						userUID: data.uid
					});
					resolve(data.uid);
				}, function (err) {
					_this6.logout();
					reject(err);
				});
			});
		}
	}, {
		key: 'getUser',
		value: function getUser() {
			var _this7 = this;

			return new Promise(function (resolve, reject) {
				_this7.request('GET', _this7.state.userServiceUrl + '?q=' + _this7.state.userUID).then(function (data) {
					var user = data[0];
					if (!user) {
						reject();
					}
					var userInfo = {
						userName: user.name,
						userEmail: user.email
					};
					_this7.state = Object.assign({}, _this7.state, userInfo);
					resolve(userInfo);
				}, function (err) {
					_this7.logout();
					reject(err);
				});
			});
		}
	}, {
		key: 'showUser',
		value: function showUser() {
			this.querySelector('#userName').innerText = this.state.userName;
		}
	}, {
		key: 'setCookie',
		value: function setCookie(token) {
			// setting domain does not work for dev localhost environment
			//document.cookie = `${this.state.tokenName}=${token},path=${this.state.cookiePath};domain=${this.state.cookieDomain};`
			document.cookie = this.state.tokenName + '=' + token + ';path=' + this.state.cookiePath + ';';
		}
	}, {
		key: 'removeCookie',
		value: function removeCookie() {
			document.cookie = this.state.tokenName + '=;path=' + this.state.cookiePath + ';domain=' + this.state.cookieDomain + ';expires=Thu, 01 Jan 1970 00:00:01 GMT";';
		}

		// HELPERS

		// matches a cookie name in the cookie string and returns the last value

	}, {
		key: 'getCookieValue',
		value: function getCookieValue(a) {
			var b = document.cookie.match('(^|;)\\s*' + a + '\\s*=\\s*([^;]+)');
			return b ? b.pop() : '';
		}
	}, {
		key: 'guid',
		value: function guid() {
			function s4() {
				return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
			}
			return '' + s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
		}

		// Method: 'GET', 'POST'

	}, {
		key: 'request',
		value: function request(method, url) {
			var _this8 = this;

			var headers = new Headers();
			return this.getToken(urlAtStart).then(function (token) {
				headers.append("Authorization", 'Bearer ' + token);
				return Promise.resolve();
			}).then(function () {
				return fetch(url, {
					method: method,
					headers: headers,
					mode: 'cors',
					cache: 'default'
				}).then(_this8.checkStatus).then(function (response) {
					return response.json();
				});
			});
		}
	}, {
		key: 'checkStatus',
		value: function checkStatus(response) {
			if (response.status >= 200 && response.status < 300) {
				return response;
			} else {
				var error = new Error(response.statusText);
				error.response = response;
				throw error;
			}
		}

		// You can also define the other lifecycle methods.

	}, {
		key: 'attachedCallback',
		value: function attachedCallback() {}
	}, {
		key: 'detachedCallback',
		value: function detachedCallback() {}
	}, {
		key: 'attributeChangedCallback',
		value: function attributeChangedCallback(attrName, oldVal, newVal) {
			switch (attrName) {
				case "redirect-url":
				case "client-id":
				case "userservice-url":
					this.getAttributes();
					break;
			}
		}
	}]);

	return WSHeader;
}(HTMLElement);

//Register the element with the document


document.registerElement('ws-header', WSHeader);
    function applyTemplate(containerElem, template) {
	'use strict';

	addLightDom(containerElem, template);

	var innerContainerSelector = '.' + containerElem.tagName.toLowerCase();

	var observer = new MutationObserver(function(mutations) {
		var changed = false;
		mutations.forEach(function(mutation) {
			var target = mutation.target;
			if (target === containerElem) {
				return;
			}
			if (target instanceof Text) {
				// text elements have no closest function
				target = target.parentNode;
			}
			// ignore changes inside of pseudo shadow dom
			if(target.closest(innerContainerSelector)) {
				return;
			}

			// console.log('Mutation:', mutation);
			changed = true;
		});

		if (changed) {
			addLightDom(containerElem, containerElem.querySelector(innerContainerSelector));
		}
	});

	// Konfiguration des Observers: alles melden - Änderungen an Daten, Kindelementen und Attributen
	var config = {
		attributes: true,
		childList: true,
		characterData: true,
		subtree:true
	};

	observer.observe(containerElem, config);
}

function addLightDom(containerElem, template) {
	'use strict';

	var innerContainerSelector = '.' + containerElem.tagName.toLowerCase();

	let contentTags = template.querySelectorAll('content');
	Array.from(contentTags).forEach(contentTag => {
		contentTag.innerHTML = '';
		let selection = contentTag.getAttribute('select');
		if (selection) {
			let selectedLightDomElems = Array.from(containerElem.querySelectorAll(selection))
				.filter(elem => !elem.closest(innerContainerSelector));

			selectedLightDomElems.forEach(selectedLightDomElem => {
				var clone = selectedLightDomElem.cloneNode(true);
				contentTag.appendChild(clone);
			});
		}
	});

	var lightDom = Array.from(containerElem.children).filter(elem => {
		return elem.classList
			&& !elem.classList.contains(innerContainerSelector.substr(1));
	});
	for(var child of lightDom) {
		if (!child.classList.contains('light-dom')) {
			child.classList.add('light-dom');
		}
	}

	containerElem.appendChild(template);
}

    /* endinject */
})()
</script>
